{"version":3,"file":"avalanche-js-contract.cjs.production.min.js","sources":["../src/abi/abiCoder.ts","../src/abi/utils.ts","../src/abi/api.ts","../src/abi/index.ts","../src/models/AbiItemModel.ts","../src/utils/status.ts","../src/models/AbiModel.ts","../src/utils/mapper.ts","../src/methods/method.ts","../src/utils/encoder.ts","../src/methods/methodFactory.ts","../src/utils/formatter.ts","../src/events/event.ts","../src/utils/decoder.ts","../src/events/eventFactory.ts","../src/contract.ts","../src/contractFactory.ts"],"sourcesContent":["/**\n # avalanche-js-contract\n\nThis package provides a collection of apis to create, deploy, and interact with smart contracts. In Avalanche, smart contracts all fully EVM compatible and the formats and terminologies match 1-to-1 with EVM smart contracts.\n\n## Installation\n\n```\nnpm install avalanche-js-contract\n```\n\n## Usage\n\nDeploying a contract using `contractConstructor`\n```javascript\nconst { ContractFactory } = require('avalanche-js-contract');\nconst { Wallet } = require('avalanche-js-account');\nconst { Messenger, HttpProvider } = require('avalanche-js-network');\nconst { ChainID, ChainType, hexToNumber } = require('avalanche-js-utils');\n\n* const wallet = new Wallet(\n*   new Messenger(\n*     new HttpProvider('https://api.s0.b.hmny.io'),\n*     ChainType.Avalanche,\n*     ChainID.HmyTestnet,\n*   ),\n* );\n* const factory = new ContractFactory(wallet);\n\n* const contractJson = require(\"./Counter.json\");\n* const contract = factory.createContract(contractJson.abi);\n\n* const options1 = { gasPrice: '0x3B9ACA00' }; // gas price in hex corresponds to 1 Gwei or 1000000000\n* let options2 = { gasPrice: 1000000000, gasLimit: 21000 }; // setting the default gas limit, but changing later based on estimate gas\n\n* const options3 = { data: contractJson.bytecode }; // contractConstructor needs contract bytecode to deploy\n\n* contract.wallet.addByPrivateKey('1f054c21a0f57ebc402c00e14bd1707ddf45542d4ed9989933dbefc4ea96ca68');\n\n* contract.methods.contractConstructor(options3).estimateGas(options1).then(gas => {\n*   options2 = {...options2, gasLimit: hexToNumber(gas)};\n*   contract.methods.contractConstructor(options3).send(options2).then(response => {\n*     console.log('contract deployed at ' + response.transaction.receipt.contractAddress);\n*   });\n* });\n```\nInstead of `contract.methods.contractConstructor`, `contract.deploy` could be used and it will work.\n\nLoading a contract object using the contract json and contract address for interacting with it\n```javascript\n* const { Avalanche } = require(\"avalanche-js-core\");\n* const { ChainID, ChainType } = require(\"avalanche-js-utils\");\n* const hmy = new Avalanche(\"https://api.s0.b.hmny.io\", {\n*   chainType: ChainType.Avalanche,\n*   chainId: ChainID.HmyTestnet,\n* });\n\nconst contractJson = require(\"./Counter.json\");\nconst contractAddr = \"0x19f64050e6b2d376e52AC426E366c49EEb0724B1\";\n\nconst contract = hmy.contracts.createContract(contractJson.abi, contractAddr);\nconsole.log(contract.methods);\n```\n\nDirectly loading contract using `ContractFactory`\n```javascript\nconst { ContractFactory } = require('avalanche-js-contract');\nconst { Wallet } = require('avalanche-js-account');\nconst { Messenger, HttpProvider } = require('avalanche-js-network');\nconst { ChainID, ChainType, hexToNumber } = require('avalanche-js-utils');\n\n* const wallet = new Wallet(new Messenger(\n*   new HttpProvider('https://api.s0.b.hmny.io'),\n*   ChainType.Avalanche,\n*   ChainID.HmyTestnet,\n* ));\nconst factory = new ContractFactory(wallet);\nconst contract = factory.createContract(contractJson.abi, contractAddr);\n```\n\nEstimate gas for contract methods\n```javascript\n* const options1 = { gasPrice: '0x3B9ACA00' }; // gas price in hex corresponds to 1 Gwei or 1000000000\n\n* contract.methods.getCount().estimateGas(options1).then(gas => {\n*   console.log('gas required for getCount is ' + hexToNumber(gas));\n* });\n```\n\nCall contract read-only methods. Avalanche uses 1 Gwei gas price and gas limit of 21000 by default. Use the estimate gas api to correctly set the gas limit.\n```javascript\n* const options1 = { gasPrice: '0x3B9ACA00' }; // gas price in hex corresponds to 1 Gwei or 1000000000\n* let options2 = { gasPrice: 1000000000, gasLimit: 21000 }; // setting the default gas limit, but changing later based on estimate gas\n\n* contract.methods.getCount().estimateGas(options1).then(gas => {\n*   options2 = {...options2, gasLimit: hexToNumber(gas)};\n*   contract.methods.getCount().call(options2).then(count => {\n*     console.log('counter value: ' + count);\n*   });\n* });\n```\n\nInvoking contract modification methods using `send` api. Need to add a signing account to the contract wallet, otherwise `send` api will not work.\n```javascript\n* const options1 = { gasPrice: '0x3B9ACA00' }; // gas price in hex corresponds to 1 Gwei or 1000000000\n* let options2 = { gasPrice: 1000000000, gasLimit: 21000 }; // setting the default gas limit, but changing later based on estimate gas\n\n* contract.wallet.addByPrivateKey('1f054c21a0f57ebc402c00e14bd1707ddf45542d4ed9989933dbefc4ea96ca68');\n\n* contract.methods.incrementCounter().estimateGas(options1).then(gas => {\n*   options2 = {...options2, gasLimit: hexToNumber(gas)};\n*   contract.methods.incrementCounter().send(options2).then(response => {\n*     console.log(response.transaction.receipt);\n*   });\n* });\n```\n\nAll the above apis can also be asynchronously executed using `async` and `await`.\n\nSubscribing to the contract events requires web socket based messenger.\n```javascript\n* const { ContractFactory } = require('avalanche-js-contract');\n* const { Wallet } = require('avalanche-js-account');\n* const { Messenger, WSProvider } = require('avalanche-js-network');\n* const { ChainID, ChainType, hexToNumber } = require('avalanche-js-utils');\n* const ws = new WSProvider('wss://ws.s0.b.hmny.io');\n\n* const wallet = new Wallet(\n*   new Messenger(\n*     ws,\n*     ChainType.Avalanche,\n*     ChainID.HmyTestnet,\n*   ),\n* );\n* const factory = new ContractFactory(wallet);\n\n* const contractJson = require(\"./Counter.json\");\n* const contractAddr = '0x8ada52172abda19b9838eb00498a40952be6a019';\n\n* const contract = factory.createContract(contractJson.abi, contractAddr);\n\n* contract.events\n*   .IncrementedBy()\n*   .on('data', (event) => {\n*     console.log(event);\n*   })\n*   .on('error', console.error);\n```\n *\n * @packageDocumentation\n * @module avalanche-contract\n */\n\n// this file is mainly ported from `ethers.js`, but done some fixes\n// 1. added bytesPadRight support\n// 2. ts-lint\n// 3. use BN as default Bignumber instance\n\nimport {\n  BN,\n  info,\n  throwError,\n  INVALID_ARGUMENT,\n  arrayify,\n  hexlify,\n  padZeros,\n  concat,\n  toChecksumAddress,\n  checkArgumentCount,\n  checkNormalize,\n  Arrayish,\n  checkNew,\n  bytesPadRight,\n} from 'avalanche-js-crypto';\nimport { hexToBN, defineReadOnly } from 'avalanche-js-utils';\n\n/** @hidden */\nconst NegativeAVAX: BN = new BN(-1);\n/** @hidden */\nconst AVAX: BN = new BN(1);\n/** @hidden */\nconst Zero: BN = new BN(0);\n/** @hidden */\nconst HashZero = '0x0000000000000000000000000000000000000000000000000000000000000000';\n/** @hidden */\nconst MaxUint256: BN = hexToBN(\n  '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',\n);\n\n/** @hidden */\nexport type CoerceFunc = (type: string, value: any) => any;\n\n/** @hidden */\nexport interface ParamType {\n  name?: string;\n  type: string;\n  indexed?: boolean;\n  components?: any[];\n}\n\n// @TODO: should this just be a combined Fragment?\n\n/** @hidden */\nexport interface EventFragment {\n  type: string;\n  name: string;\n\n  anonymous: boolean;\n\n  inputs: ParamType[];\n}\n\n/** @hidden */\nexport interface FunctionFragment {\n  type: string;\n  name: string;\n\n  constant: boolean;\n\n  inputs: ParamType[];\n  outputs: ParamType[];\n\n  payable: boolean;\n  stateMutability: string | null;\n\n  gas: BN | null;\n}\n\n///////////////////////////////\n/** @hidden */\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n/** @hidden */\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n/** @hidden */\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\n/** @hidden */\nexport const defaultCoerceFunc: CoerceFunc = (type: string, value: any): any => {\n  const match = type.match(paramTypeNumber);\n  if (match && parseInt(match[2], 10) <= 48) {\n    // return value.toNumber();\n    return value.toString('hex');\n  }\n  return value;\n};\n\n///////////////////////////////////\n// Parsing for Solidity Signatures\n\n///////////////////////////////////\n// Parsing for Solidity Signatures\n\n/** @hidden */\nconst regexParen = new RegExp('^([^)(]*)\\\\((.*)\\\\)([^)(]*)$');\n/** @hidden */\nconst regexIdentifier = new RegExp('^[A-Za-z_][A-Za-z0-9_]*$');\n\n/** @hidden */\nfunction verifyType(type: string): string {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = 'uint256' + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = 'int256' + type.substring(3);\n  }\n\n  return type;\n}\n\n/** @hidden */\ninterface ParseState {\n  allowArray?: boolean;\n  allowName?: boolean;\n  allowParams?: boolean;\n  allowType?: boolean;\n  readArray?: boolean;\n}\n\n/** @hidden */\ninterface ParseNode {\n  parent?: any;\n  type?: string;\n  name?: string;\n  state?: ParseState;\n  indexed?: boolean;\n  components?: any[];\n}\n\n/** @hidden */\nfunction parseParam(param: string, allowIndexed?: boolean): ParamType {\n  const originalParam = param;\n  // tslint:disable-next-line: no-shadowed-variable\n  function throwError(i: number) {\n    throw new Error(\n      'unexpected character \"' +\n        originalParam[i] +\n        '\" at position ' +\n        i +\n        ' in \"' +\n        originalParam +\n        '\"',\n    );\n  }\n  param = param.replace(/\\s/g, ' ');\n\n  const parent: ParseNode = { type: '', name: '', state: { allowType: true } };\n  let node = parent;\n\n  for (let i = 0; i < param.length; i++) {\n    const c = param[i];\n    switch (c) {\n      case '(':\n        if (!node.state || !node.state.allowParams) {\n          throwError(i);\n        }\n        if (node.state) {\n          node.state.allowType = false;\n        }\n        if (node.type) {\n          node.type = verifyType(node.type);\n        }\n\n        node.components = [{ type: '', name: '', parent: node, state: { allowType: true } }];\n        node = node.components[0];\n        break;\n\n      case ')':\n        delete node.state;\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n        if (node.type) {\n          node.type = verifyType(node.type);\n        }\n\n        const child = node;\n        node = node.parent;\n        if (!node) {\n          throwError(i);\n        }\n        delete child.parent;\n        if (node.state) {\n          node.state.allowParams = false;\n          node.state.allowName = true;\n          node.state.allowArray = true;\n        }\n\n        break;\n\n      case ',':\n        delete node.state;\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n        if (node.type) {\n          node.type = verifyType(node.type);\n        }\n\n        const sibling: ParseNode = {\n          type: '',\n          name: '',\n          parent: node.parent,\n          state: { allowType: true },\n        };\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n\n      // Hit a space...\n      case ' ':\n        // If reading type, the type is done and may read a param or name\n        if (node.state) {\n          if (node.state.allowType) {\n            if (node.type !== '' && node.type) {\n              node.type = verifyType(node.type);\n              delete node.state.allowType;\n              node.state.allowName = true;\n              node.state.allowParams = true;\n            }\n          }\n\n          // If reading name, the name is done\n          if (node.state.allowName) {\n            if (node.name !== '') {\n              if (allowIndexed && node.name === 'indexed') {\n                node.indexed = true;\n                node.name = '';\n              } else {\n                node.state.allowName = false;\n              }\n            }\n          }\n        }\n\n        break;\n\n      case '[':\n        if (!node.state || !node.state.allowArray) {\n          throwError(i);\n        }\n        if (node.state) {\n          node.type += c;\n          node.state.allowArray = false;\n          node.state.allowName = false;\n          node.state.readArray = true;\n        }\n\n        break;\n\n      case ']':\n        if (!node.state || !node.state.readArray) {\n          throwError(i);\n        }\n        if (node.state) {\n          node.type += c;\n\n          node.state.readArray = false;\n          node.state.allowArray = true;\n          node.state.allowName = true;\n        }\n\n        break;\n\n      default:\n        if (node.state) {\n          if (node.state.allowType) {\n            node.type += c;\n            node.state.allowParams = true;\n            node.state.allowArray = true;\n          } else if (node.state.allowName) {\n            node.name += c;\n            delete node.state.allowArray;\n          } else if (node.state.readArray) {\n            node.type += c;\n          } else {\n            throwError(i);\n          }\n        }\n    }\n  }\n\n  if (node.parent) {\n    throw new Error('unexpected eof');\n  }\n\n  delete parent.state;\n\n  if (allowIndexed && node.name === 'indexed') {\n    node.indexed = true;\n    node.name = '';\n  }\n\n  if (parent.type) {\n    parent.type = verifyType(parent.type);\n  }\n\n  return <ParamType>parent;\n}\n\n// @TODO: Better return type\n/** @hidden */\nfunction parseSignatureEvent(fragment: string): EventFragment {\n  const abi: EventFragment = {\n    anonymous: false,\n    inputs: [],\n    name: '',\n    type: 'event',\n  };\n\n  const match = fragment.match(regexParen);\n  if (!match) {\n    throw new Error('invalid event: ' + fragment);\n  }\n\n  abi.name = match[1].trim();\n\n  splitNesting(match[2]).forEach((param) => {\n    param = parseParam(param, true);\n    param.indexed = !!param.indexed;\n    abi.inputs.push(param);\n  });\n\n  match[3].split(' ').forEach((modifier) => {\n    switch (modifier) {\n      case 'anonymous':\n        abi.anonymous = true;\n        break;\n      case '':\n        break;\n      default:\n        info('unknown modifier: ' + modifier);\n    }\n  });\n\n  if (abi.name && !abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + abi.name + '\"');\n  }\n\n  return abi;\n}\n\n/** @hidden */\nexport function parseParamType(type: string): ParamType {\n  return parseParam(type, true);\n}\n\n// @TODO: Allow a second boolean to expose names\n/** @hidden */\nexport function formatParamType(paramType: ParamType): string {\n  return getParamCoder(defaultCoerceFunc, paramType).type;\n}\n\n/** @hidden */\nfunction parseSignatureFunction(fragment: string): FunctionFragment {\n  const abi: FunctionFragment = {\n    constant: false,\n    gas: null,\n    inputs: [],\n    name: '',\n    outputs: [],\n    payable: false,\n    stateMutability: null, // @TODO: Should this be initialized to 'nonpayable'?\n    type: 'function',\n  };\n\n  let comps = fragment.split('@');\n  if (comps.length !== 1) {\n    if (comps.length > 2) {\n      throw new Error('invalid signature');\n    }\n    if (!comps[1].match(/^[0-9]+$/)) {\n      throw new Error('invalid signature gas');\n    }\n    abi.gas = new BN(comps[1]);\n    fragment = comps[0];\n  }\n\n  comps = fragment.split(' returns ');\n  const left = comps[0].match(regexParen);\n  if (!left) {\n    throw new Error('invalid signature');\n  }\n\n  abi.name = left[1].trim();\n  if (!abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + left[1] + '\"');\n  }\n\n  splitNesting(left[2]).forEach((param) => {\n    abi.inputs.push(parseParam(param));\n  });\n\n  left[3].split(' ').forEach((modifier) => {\n    switch (modifier) {\n      case 'constant':\n        abi.constant = true;\n        break;\n      case 'payable':\n        abi.payable = true;\n        abi.stateMutability = 'payable';\n        break;\n      case 'pure':\n        abi.constant = true;\n        abi.stateMutability = 'pure';\n        break;\n      case 'view':\n        abi.constant = true;\n        abi.stateMutability = 'view';\n        break;\n      case 'external':\n      case 'public':\n      case '':\n        break;\n      default:\n        info('unknown modifier: ' + modifier);\n    }\n  });\n\n  // We have outputs\n  if (comps.length > 1) {\n    const right = comps[1].match(regexParen);\n    if (right === null || right[1].trim() !== '' || right[3].trim() !== '') {\n      throw new Error('unexpected tokens');\n    }\n\n    splitNesting(right[2]).forEach((param) => {\n      abi.outputs.push(parseParam(param));\n    });\n  }\n\n  if (abi.name === 'constructor') {\n    abi.type = 'constructor';\n\n    if (abi.outputs.length) {\n      throw new Error('constructor may not have outputs');\n    }\n\n    delete abi.name;\n    delete abi.outputs;\n  }\n\n  return abi;\n}\n\n// @TODO: Allow a second boolean to expose names and modifiers\n/** @hidden */\nexport function formatSignature(fragment: EventFragment | FunctionFragment): string {\n  return fragment.name + '(' + fragment.inputs.map((i) => formatParamType(i)).join(',') + ')';\n}\n\n/** @hidden */\nexport function parseSignature(fragment: string): EventFragment | FunctionFragment {\n  if (typeof fragment === 'string') {\n    // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n    fragment = fragment.replace(/\\s/g, ' ');\n    fragment = fragment\n      .replace(/\\(/g, ' (')\n      .replace(/\\)/g, ') ')\n      .replace(/\\s+/g, ' ');\n    fragment = fragment.trim();\n\n    if (fragment.substring(0, 6) === 'event ') {\n      return parseSignatureEvent(fragment.substring(6).trim());\n    } else {\n      if (fragment.substring(0, 9) === 'function ') {\n        fragment = fragment.substring(9);\n      }\n      return parseSignatureFunction(fragment.trim());\n    }\n  }\n\n  throw new Error('unknown signature');\n}\n\n///////////////////////////////////\n// Coders\n/** @hidden */\ninterface DecodedResult {\n  consumed: number;\n  value: any;\n}\n\n/** @hidden */\nabstract class Coder {\n  readonly coerceFunc: CoerceFunc;\n  readonly name: string;\n  readonly type: string;\n  readonly localName?: string;\n  readonly dynamic: boolean;\n  constructor(\n    coerceFunc: CoerceFunc,\n    name: string,\n    type: string,\n    localName: string | undefined,\n    dynamic: boolean,\n  ) {\n    this.coerceFunc = coerceFunc;\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n\n  abstract encode(value: any): Uint8Array;\n  abstract decode(data: Uint8Array, offset: number): DecodedResult;\n}\n\n// Clones the functionality of an existing Coder, but without a localName\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderAnonymous extends Coder {\n  private coder: Coder;\n  constructor(coder: Coder) {\n    super(coder.coerceFunc, coder.name, coder.type, undefined, coder.dynamic);\n    this.coder = coder;\n  }\n  encode(value: any): Uint8Array {\n    return this.coder.encode(value);\n  }\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    return this.coder.decode(data, offset);\n  }\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderNull extends Coder {\n  constructor(coerceFunc: CoerceFunc, localName: string) {\n    super(coerceFunc, 'null', '', localName, false);\n  }\n\n  encode(value: any): Uint8Array {\n    const result = arrayify([]) || new Uint8Array();\n    return result;\n  }\n\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    if (offset > data.length) {\n      throw new Error('invalid null');\n    }\n    return {\n      consumed: 0,\n      value: this.coerceFunc('null', undefined),\n    };\n  }\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderNumber extends Coder {\n  readonly size: number;\n  readonly signed: boolean;\n  constructor(coerceFunc: CoerceFunc, size: number, signed: boolean, localName: string) {\n    const name = (signed ? 'int' : 'uint') + size * 8;\n    super(coerceFunc, name, name, localName, false);\n\n    this.size = size;\n    this.signed = signed;\n  }\n\n  encode(value: BN | number | string): Uint8Array {\n    let result;\n    try {\n      let v: BN;\n      if (typeof value == 'string' && value.startsWith('0x')) {\n        v = new BN(value.slice(2), 'hex');\n      } else {\n        v = new BN(value);\n      }\n      if (this.signed) {\n        let bounds = MaxUint256.maskn(this.size * 8 - 1);\n        if (v.gt(bounds)) {\n          throw new Error('out-of-bounds');\n        }\n        bounds = bounds.add(AVAX).mul(NegativeAVAX);\n        if (v.lt(bounds)) {\n          throw new Error('out-of-bounds');\n        }\n      } else if (v.lt(Zero) || v.gt(MaxUint256.maskn(this.size * 8))) {\n        throw new Error('out-of-bounds');\n      }\n\n      v = v.toTwos(this.size * 8).maskn(this.size * 8);\n      if (this.signed) {\n        v = v.fromTwos(this.size * 8).toTwos(256);\n      }\n      const vString = v.toString('hex');\n\n      result = padZeros(arrayify(`0x${vString}`) || new Uint8Array(), 32);\n    } catch (error) {\n      throwError('invalid number value', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value,\n      });\n    }\n    return result || padZeros(new Uint8Array(), 32);\n  }\n\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    if (data.length < offset + 32) {\n      throwError('insufficient data for ' + this.name + ' type', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: hexlify(data.slice(offset, offset + 32)),\n      });\n    }\n    const junkLength = 32 - this.size;\n    const dataValue = hexlify(data.slice(offset + junkLength, offset + 32));\n\n    let value = hexToBN(dataValue);\n    // tslint:disable-next-line: prefer-conditional-expression\n    if (this.signed) {\n      value = value.fromTwos(this.size * 8);\n    } else {\n      value = value.maskn(this.size * 8);\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, value),\n    };\n  }\n}\n\n/** @hidden */\nconst uint256Coder = new CoderNumber(\n  (type: string, value: any) => {\n    return value;\n  },\n  32,\n  false,\n  'none',\n);\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderBoolean extends Coder {\n  constructor(coerceFunc: CoerceFunc, localName: string) {\n    super(coerceFunc, 'bool', 'bool', localName, false);\n  }\n\n  encode(value: boolean): Uint8Array {\n    return uint256Coder.encode(!!value ? new BN(1) : new BN(0));\n  }\n\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    let result;\n    try {\n      result = uint256Coder.decode(data, offset);\n    } catch (error) {\n      if (error.reason === 'insufficient data for uint256 type') {\n        throwError('insufficient data for boolean type', INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'boolean',\n          value: error.value,\n        });\n      }\n      throw error;\n    }\n    return {\n      consumed: result.consumed,\n      value: this.coerceFunc('bool', !result.value.isZero()),\n    };\n  }\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderFixedBytes extends Coder {\n  readonly length: number;\n  constructor(coerceFunc: CoerceFunc, length: number, localName: string) {\n    const name = 'bytes' + length;\n    super(coerceFunc, name, name, localName, false);\n    this.length = length;\n  }\n\n  encode(value: Arrayish): Uint8Array {\n    const result = new Uint8Array(this.length);\n\n    try {\n      const arrayied = arrayify(value);\n      let data = null;\n      if (arrayied !== null) {\n        const valueToByte = hexlify(arrayied);\n        data = arrayify(bytesPadRight(valueToByte, this.length));\n      } else {\n        throw new Error('cannot arraify data');\n      }\n\n      if (data === null || data.length !== this.length) {\n        throw new Error('incorrect data length');\n      }\n      result.set(data);\n    } catch (error) {\n      throwError('invalid ' + this.name + ' value', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: error.value || value,\n      });\n    }\n    return result;\n  }\n\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    if (data.length < offset + 32) {\n      throwError('insufficient data for ' + name + ' type', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: hexlify(data.slice(offset, offset + 32)),\n      });\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, hexlify(data.slice(offset, offset + this.length))),\n    };\n  }\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderAddress extends Coder {\n  constructor(coerceFunc: CoerceFunc, localName: string) {\n    super(coerceFunc, 'address', 'address', localName, false);\n  }\n  encode(value: string): Uint8Array {\n    const result = new Uint8Array(32);\n    try {\n      const addr = arrayify(toChecksumAddress(value)) || new Uint8Array();\n      result.set(addr, 12);\n    } catch (error) {\n      throwError('invalid address', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value,\n      });\n    }\n    return result;\n  }\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    if (data.length < offset + 32) {\n      throwError('insufficuent data for address type', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value: hexlify(data.slice(offset, offset + 32)),\n      });\n    }\n    return {\n      consumed: 32,\n      value: this.coerceFunc(\n        'address',\n        toChecksumAddress(hexlify(data.slice(offset + 12, offset + 32))),\n      ),\n    };\n  }\n}\n\n/** @hidden */\nfunction _encodeDynamicBytes(value: Uint8Array): Uint8Array {\n  const dataLength = 32 * Math.ceil(value.length / 32);\n  const padding = new Uint8Array(dataLength - value.length);\n\n  return concat([uint256Coder.encode(new BN(value.length)), value, padding]);\n}\n\n/** @hidden */\nfunction _decodeDynamicBytes(data: Uint8Array, offset: number, localName: string): DecodedResult {\n  if (data.length < offset + 32) {\n    throwError('insufficient data for dynamicBytes length', INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: hexlify(data.slice(offset, offset + 32)),\n    });\n  }\n\n  let length = uint256Coder.decode(data, offset).value;\n\n  try {\n    length = length.toNumber();\n  } catch (error) {\n    throwError('dynamic bytes count too large', INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: length.toString(),\n    });\n  }\n\n  if (data.length < offset + 32 + length) {\n    throwError('insufficient data for dynamicBytes type', INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: hexlify(data.slice(offset, offset + 32 + length)),\n    });\n  }\n\n  return {\n    consumed: 32 + 32 * Math.ceil(length / 32),\n    value: data.slice(offset + 32, offset + 32 + length),\n  };\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderDynamicBytes extends Coder {\n  constructor(coerceFunc: CoerceFunc, localName: string) {\n    super(coerceFunc, 'bytes', 'bytes', localName, true);\n  }\n  encode(value: Arrayish): Uint8Array {\n    let result = new Uint8Array();\n    try {\n      result = _encodeDynamicBytes(arrayify(value) || new Uint8Array());\n    } catch (error) {\n      throwError('invalid bytes value', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'bytes',\n        value: error.value,\n      });\n    }\n    return result;\n  }\n\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    const result = _decodeDynamicBytes(data, offset, this.localName || '');\n    result.value = this.coerceFunc('bytes', hexlify(result.value));\n    return result;\n  }\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderString extends Coder {\n  constructor(coerceFunc: CoerceFunc, localName: string) {\n    super(coerceFunc, 'string', 'string', localName, true);\n  }\n\n  encode(value: string): Uint8Array {\n    if (typeof value !== 'string') {\n      throwError('invalid string value', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'string',\n        value,\n      });\n    }\n    return _encodeDynamicBytes(toUtf8Bytes(value));\n  }\n\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    const result = _decodeDynamicBytes(data, offset, this.localName || '');\n    result.value = this.coerceFunc('string', toUtf8String(result.value));\n    return result;\n  }\n}\n\n/** @hidden */\nfunction alignSize(size: number): number {\n  return 32 * Math.ceil(size / 32);\n}\n\n/** @hidden */\nfunction pack(coders: Coder[], values: any[]): Uint8Array {\n  if (Array.isArray(values)) {\n    // do nothing\n  } else if (values && typeof values === 'object') {\n    const arrayValues: any[] = [];\n    coders.forEach((coder) => {\n      arrayValues.push((<any>values)[coder.localName || '']);\n    });\n    values = arrayValues;\n  } else {\n    throwError('invalid tuple value', INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values,\n    });\n  }\n\n  if (coders.length !== values.length) {\n    throwError('types/value length mismatch', INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values,\n    });\n  }\n\n  const parts: Array<{ dynamic: boolean; value: any }> = [];\n\n  coders.forEach((coder, index) => {\n    parts.push({ dynamic: coder.dynamic, value: coder.encode(values[index]) });\n  });\n\n  let staticSize = 0;\n  let dynamicSize = 0;\n  parts.forEach((part) => {\n    if (part.dynamic) {\n      staticSize += 32;\n      dynamicSize += alignSize(part.value.length);\n    } else {\n      staticSize += alignSize(part.value.length);\n      // todo : is it to be static size not alignSize?\n    }\n  });\n\n  let offset = 0;\n  let dynamicOffset = staticSize;\n  const data = new Uint8Array(staticSize + dynamicSize);\n\n  parts.forEach((part) => {\n    if (part.dynamic) {\n      // uint256Coder.encode(dynamicOffset).copy(data, offset);\n      data.set(uint256Coder.encode(new BN(dynamicOffset)), offset);\n      offset += 32;\n\n      // part.value.copy(data, dynamicOffset);  @TODO\n      data.set(part.value, dynamicOffset);\n      dynamicOffset += alignSize(part.value.length);\n    } else {\n      // part.value.copy(data, offset);  @TODO\n      data.set(part.value, offset);\n      offset += alignSize(part.value.length);\n    }\n  });\n\n  return data;\n}\n\n/** @hidden */\nfunction unpack(coders: Coder[], data: Uint8Array, offset: number): DecodedResult {\n  const baseOffset = offset;\n  let consumed = 0;\n  const value: any = [];\n  coders.forEach((coder) => {\n    let result: DecodedResult;\n    if (coder.dynamic) {\n      const dynamicOffset = uint256Coder.decode(data, offset);\n      result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber());\n      // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n      result.consumed = dynamicOffset.consumed;\n    } else {\n      result = coder.decode(data, offset);\n    }\n\n    if (result.value !== undefined) {\n      value.push(result.value);\n    }\n\n    offset += result.consumed;\n    consumed += result.consumed;\n  });\n\n  coders.forEach((coder: Coder, index: number) => {\n    let name: string | undefined = coder.localName;\n    if (!name) {\n      return;\n    }\n\n    if (name === 'length') {\n      name = '_length';\n    }\n\n    if (value[name] != null) {\n      return;\n    }\n\n    value[name] = value[index];\n  });\n\n  return {\n    value,\n    consumed,\n  };\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderArray extends Coder {\n  readonly coder: Coder;\n  readonly length: number;\n  constructor(coerceFunc: CoerceFunc, coder: Coder, length: number, localName: string) {\n    const type = coder.type + '[' + (length >= 0 ? length : '') + ']';\n    const dynamic = length === -1 || coder.dynamic;\n    super(coerceFunc, 'array', type, localName, dynamic);\n\n    this.coder = coder;\n    this.length = length;\n  }\n\n  encode(value: any[]): Uint8Array {\n    if (!Array.isArray(value)) {\n      throwError('expected array value', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'array',\n        value,\n      });\n    }\n\n    let count = this.length;\n\n    let result = new Uint8Array(0);\n    if (count === -1) {\n      count = value.length;\n      result = uint256Coder.encode(new BN(count));\n    }\n\n    checkArgumentCount(\n      count,\n      value.length,\n      ' in coder array' + (this.localName ? ' ' + this.localName : ''),\n    );\n\n    const coders = [];\n    // tslint:disable-next-line: prefer-for-of\n    for (let i = 0; i < value.length; i++) {\n      coders.push(this.coder);\n    }\n\n    return concat([result, pack(coders, value)]);\n  }\n\n  decode(data: Uint8Array, offset: number) {\n    // @TODO:\n    // if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n\n    let consumed = 0;\n\n    let count = this.length;\n\n    let decodedLength: DecodedResult = { consumed: 0, value: undefined };\n    if (count === -1) {\n      try {\n        decodedLength = uint256Coder.decode(data, offset);\n      } catch (error) {\n        throwError('insufficient data for dynamic array length', INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: error.value,\n        });\n      }\n      try {\n        count = decodedLength.value.toNumber();\n      } catch (error) {\n        throwError('array count too large', INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: decodedLength.value.toString(),\n        });\n      }\n      consumed += decodedLength.consumed;\n      offset += decodedLength.consumed;\n    }\n\n    const coders = [];\n    for (let i = 0; i < count; i++) {\n      coders.push(new CoderAnonymous(this.coder));\n    }\n\n    const result = unpack(coders, data, offset);\n    result.consumed += consumed;\n    result.value = this.coerceFunc(this.type, result.value);\n    return result;\n  }\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderTuple extends Coder {\n  readonly coders: Coder[];\n  constructor(coerceFunc: CoerceFunc, coders: Coder[], localName: string) {\n    let dynamic = false;\n    const types: string[] = [];\n    coders.forEach((coder) => {\n      if (coder.dynamic) {\n        dynamic = true;\n      }\n      types.push(coder.type);\n    });\n    const type = 'tuple(' + types.join(',') + ')';\n\n    super(coerceFunc, 'tuple', type, localName, dynamic);\n    this.coders = coders;\n  }\n\n  encode(value: any[]): Uint8Array {\n    return pack(this.coders, value);\n  }\n\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    const result = unpack(this.coders, data, offset);\n    result.value = this.coerceFunc(this.type, result.value);\n\n    return result;\n  }\n}\n\n/** @hidden */\nfunction splitNesting(value: string): any[] {\n  value = value.trim();\n\n  const result = [];\n  let accum = '';\n  let depth = 0;\n\n  // tslint:disable-next-line: prefer-for-of\n  for (let offset = 0; offset < value.length; offset++) {\n    const c = value[offset];\n    if (c === ',' && depth === 0) {\n      result.push(accum);\n      accum = '';\n    } else {\n      accum += c;\n      if (c === '(') {\n        depth++;\n      } else if (c === ')') {\n        depth--;\n        if (depth === -1) {\n          throw new Error('unbalanced parenthsis');\n        }\n      }\n    }\n  }\n  if (accum) {\n    result.push(accum);\n  }\n\n  return result;\n}\n\n// @TODO: Is there a way to return \"class\"?\n/** @hidden */\nconst paramTypeSimple: { [key: string]: any } = {\n  address: CoderAddress,\n  bool: CoderBoolean,\n  string: CoderString,\n  bytes: CoderDynamicBytes,\n};\n\n/** @hidden */\nfunction getTupleParamCoder(\n  coerceFunc: CoerceFunc,\n  components: any[],\n  localName: string,\n): CoderTuple {\n  if (!components) {\n    components = [];\n  }\n  const coders: Coder[] = [];\n  components.forEach((component) => {\n    coders.push(getParamCoder(coerceFunc, component));\n  });\n\n  return new CoderTuple(coerceFunc, coders, localName);\n}\n\n/** @hidden */\nfunction getParamCoder(coerceFunc: CoerceFunc, param: ParamType | any): any {\n  const coder = paramTypeSimple[param.type];\n  if (coder) {\n    return new coder(coerceFunc, param.name);\n  }\n  const matcher = param.type.match(paramTypeNumber);\n  if (matcher) {\n    const size = parseInt(matcher[2] || '256', 10);\n    if (size === 0 || size > 256 || size % 8 !== 0) {\n      throwError('invalid ' + matcher[1] + ' bit length', INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param,\n      });\n    }\n    return new CoderNumber(coerceFunc, size / 8, matcher[1] === 'int', param.name || '');\n  }\n\n  const matcher2 = param.type.match(paramTypeBytes);\n  if (matcher2) {\n    const size = parseInt(matcher2[1], 10);\n    if (size === 0 || size > 32) {\n      throwError('invalid bytes length', INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param,\n      });\n    }\n    return new CoderFixedBytes(coerceFunc, size, param.name || '');\n  }\n\n  const matcher3 = param.type.match(paramTypeArray);\n  if (matcher3) {\n    const size = parseInt(matcher3[2] || '-1', 10);\n    param = shallowCopy(param);\n    param.type = matcher3[1];\n    param = deepCopy(param);\n    return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name || '');\n  }\n\n  if (param.type.substring(0, 5) === 'tuple') {\n    return getTupleParamCoder(coerceFunc, param.components || [], param.name || '');\n  }\n\n  if (param.type === '') {\n    return new CoderNull(coerceFunc, param.name || '');\n  }\n\n  throwError('invalid type', INVALID_ARGUMENT, {\n    arg: 'type',\n    value: param.type,\n  });\n}\n\n/** @hidden */\nexport enum UnicodeNormalizationForm {\n  current = '',\n  NFC = 'NFC',\n  NFD = 'NFD',\n  NFKC = 'NFKC',\n  NFKD = 'NFKD',\n}\n\n/** @hidden */\nexport function toUtf8Bytes(\n  str: string,\n  form: UnicodeNormalizationForm = UnicodeNormalizationForm.current,\n): Uint8Array {\n  if (form !== UnicodeNormalizationForm.current) {\n    checkNormalize();\n    str = str.normalize(form);\n  }\n\n  const result = [];\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i);\n\n    if (c < 0x80) {\n      result.push(c);\n    } else if (c < 0x800) {\n      result.push((c >> 6) | 0xc0);\n      result.push((c & 0x3f) | 0x80);\n    } else if ((c & 0xfc00) === 0xd800) {\n      i++;\n      const c2 = str.charCodeAt(i);\n\n      if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n        throw new Error('invalid utf-8 string');\n      }\n\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n      result.push((c >> 18) | 0xf0);\n      result.push(((c >> 12) & 0x3f) | 0x80);\n      result.push(((c >> 6) & 0x3f) | 0x80);\n      result.push((c & 0x3f) | 0x80);\n    } else {\n      result.push((c >> 12) | 0xe0);\n      result.push(((c >> 6) & 0x3f) | 0x80);\n      result.push((c & 0x3f) | 0x80);\n    }\n  }\n\n  return arrayify(result) || new Uint8Array();\n}\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\n/** @hidden */\nexport function toUtf8String(bytes: Arrayish, ignoreErrors?: boolean): string {\n  bytes = arrayify(bytes) || new Uint8Array();\n\n  let result = '';\n  let i = 0;\n\n  // Invalid bytes are ignored\n  while (i < bytes.length) {\n    const c = bytes[i++];\n    // 0xxx xxxx\n    if (c >> 7 === 0) {\n      result += String.fromCharCode(c);\n      continue;\n    }\n\n    // Multibyte; how many bytes left for this character?\n    let extraLength = null;\n    let overlongMask = null;\n\n    // 110x xxxx 10xx xxxx\n    if ((c & 0xe0) === 0xc0) {\n      extraLength = 1;\n      overlongMask = 0x7f;\n\n      // 1110 xxxx 10xx xxxx 10xx xxxx\n    } else if ((c & 0xf0) === 0xe0) {\n      extraLength = 2;\n      overlongMask = 0x7ff;\n\n      // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n    } else if ((c & 0xf8) === 0xf0) {\n      extraLength = 3;\n      overlongMask = 0xffff;\n    } else {\n      if (!ignoreErrors) {\n        if ((c & 0xc0) === 0x80) {\n          throw new Error('invalid utf8 byte sequence; unexpected continuation byte');\n        }\n        throw new Error('invalid utf8 byte sequence; invalid prefix');\n      }\n      continue;\n    }\n\n    // Do we have enough bytes in our data?\n    if (i + extraLength > bytes.length) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; too short');\n      }\n\n      // If there is an invalid unprocessed byte, skip continuation bytes\n      for (; i < bytes.length; i++) {\n        if (bytes[i] >> 6 !== 0x02) {\n          break;\n        }\n      }\n\n      continue;\n    }\n\n    // Remove the length prefix from the char\n    let res: number | null = c & ((1 << (8 - extraLength - 1)) - 1);\n\n    for (let j = 0; j < extraLength; j++) {\n      const nextChar = bytes[i];\n\n      // Invalid continuation byte\n      if ((nextChar & 0xc0) !== 0x80) {\n        res = null;\n        break;\n      }\n\n      res = (res << 6) | (nextChar & 0x3f);\n      i++;\n    }\n\n    if (res === null) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; invalid continuation byte');\n      }\n      continue;\n    }\n\n    // Check for overlong seuences (more bytes than needed)\n    if (res <= overlongMask) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; overlong');\n      }\n      continue;\n    }\n\n    // Maximum code point\n    if (res > 0x10ffff) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; out-of-range');\n      }\n      continue;\n    }\n\n    // Reserved for UTF-16 surrogate halves\n    if (res >= 0xd800 && res <= 0xdfff) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; utf-16 surrogate');\n      }\n      continue;\n    }\n\n    if (res <= 0xffff) {\n      result += String.fromCharCode(res);\n      continue;\n    }\n\n    res -= 0x10000;\n    result += String.fromCharCode(((res >> 10) & 0x3ff) + 0xd800, (res & 0x3ff) + 0xdc00);\n  }\n\n  return result;\n}\n\n/** @hidden */\nexport function formatBytes32String(text: string): string {\n  // Get the bytes\n  const bytes = toUtf8Bytes(text);\n\n  // Check we have room for null-termination\n  if (bytes.length > 31) {\n    throw new Error('bytes32 string must be less than 32 bytes');\n  }\n\n  // Zero-pad (implicitly null-terminates)\n  return hexlify(concat([bytes, HashZero]).slice(0, 32));\n}\n\n/** @hidden */\nexport function parseBytes32String(bytes: Arrayish): string {\n  const data = arrayify(bytes) || new Uint8Array();\n\n  // Must be 32 bytes with a null-termination\n  if (data.length !== 32) {\n    throw new Error('invalid bytes32 - not 32 bytes long');\n  }\n  if (data[31] !== 0) {\n    throw new Error('invalid bytes32 sdtring - no null terminator');\n  }\n\n  // Find the null termination\n  let length = 31;\n  while (data[length - 1] === 0) {\n    length--;\n  }\n\n  // Determine the string value\n  return toUtf8String(data.slice(0, length));\n}\n\n/** @hidden */\nexport function isType(object: any, type: string): boolean {\n  return object && object._ethersType === type;\n}\n\n/** @hidden */\nexport function shallowCopy(object: any): any {\n  const result: any = {};\n  // tslint:disable-next-line: forin\n  for (const key in object) {\n    result[key] = object[key];\n  }\n  return result;\n}\n\n/** @hidden */\nconst opaque: { [key: string]: boolean } = {\n  boolean: true,\n  number: true,\n  string: true,\n};\n\n/** @hidden */\nexport function deepCopy(object: any, frozen?: boolean): any {\n  // Opaque objects are not mutable, so safe to copy by assignment\n  if (object === undefined || object === null || opaque[typeof object]) {\n    return object;\n  }\n\n  // Arrays are mutable, so we need to create a copy\n  if (Array.isArray(object)) {\n    const result = object.map((item) => deepCopy(item, frozen));\n    if (frozen) {\n      Object.freeze(result);\n    }\n    return result;\n  }\n\n  if (typeof object === 'object') {\n    // Some internal objects, which are already immutable\n    if (isType(object, 'BigNumber')) {\n      return object;\n    }\n    if (isType(object, 'Description')) {\n      return object;\n    }\n    if (isType(object, 'Indexed')) {\n      return object;\n    }\n\n    const result: { [key: string]: any } = {};\n    // tslint:disable-next-line: forin\n    for (const key in object) {\n      const value = object[key];\n      if (value === undefined) {\n        continue;\n      }\n      defineReadOnly(result, key, deepCopy(value, frozen));\n    }\n\n    if (frozen) {\n      Object.freeze(result);\n    }\n\n    return result;\n  }\n\n  // The function type is also immutable, so safe to copy by assignment\n  if (typeof object === 'function') {\n    return object;\n  }\n\n  throw new Error('Cannot deepCopy ' + typeof object);\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nexport class AbiCoder {\n  coerceFunc: CoerceFunc;\n  constructor(coerceFunc?: CoerceFunc) {\n    checkNew(this, AbiCoder);\n\n    if (!coerceFunc) {\n      coerceFunc = defaultCoerceFunc;\n    }\n    this.coerceFunc = coerceFunc;\n  }\n\n  encode(types: Array<string | ParamType>, values: any[]): string {\n    if (types.length !== values.length) {\n      throwError('types/values length mismatch', INVALID_ARGUMENT, {\n        count: { types: types.length, values: values.length },\n        value: { types, values },\n      });\n    }\n\n    const coders: Coder[] = [];\n    types.forEach((type) => {\n      // Convert types to type objects\n      //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n      //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n\n      let typeObject: ParamType | null = null;\n      // tslint:disable-next-line: prefer-conditional-expression\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = type;\n      }\n\n      coders.push(getParamCoder(this.coerceFunc, typeObject));\n    }, this);\n    const encodedArray = new CoderTuple(this.coerceFunc, coders, '_').encode(values);\n    return hexlify(encodedArray);\n  }\n\n  decode(types: Array<string | ParamType>, data: Arrayish): any {\n    const coders: Coder[] = [];\n    types.forEach((type) => {\n      // See encode for details\n      let typeObject: ParamType | null = null;\n      // tslint:disable-next-line: prefer-conditional-expression\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = deepCopy(type);\n      }\n\n      coders.push(getParamCoder(this.coerceFunc, typeObject));\n    }, this);\n    const result = new CoderTuple(this.coerceFunc, coders, '_').decode(\n      arrayify(data) || new Uint8Array(),\n      0,\n    ).value;\n    return result;\n  }\n}\n\n/** @hidden */\nexport const defaultAbiCoder: AbiCoder = new AbiCoder();\n","/**\n * @packageDocumentation\n * @module avalanche-contract\n * @hidden\n */\n\nimport { isObject, isArray } from 'avalanche-js-utils';\nimport { BN } from 'avalanche-js-crypto';\n\nexport const jsonInterfaceMethodToString = (json: any): string => {\n  if (isObject(json) && json.name && json.name.includes('(')) {\n    return json.name;\n  }\n\n  return `${json.name}(${flattenTypes(false, json.inputs).join(',')})`;\n};\n\nexport const flattenTypes = (includeTuple: any, puts: any[]) => {\n  // console.log(\"entered _flattenTypes. inputs/outputs: \" + puts)\n  const types: any[] = [];\n\n  puts.forEach((param: any) => {\n    if (typeof param.components === 'object') {\n      if (param.type.substring(0, 5) !== 'tuple') {\n        throw new Error('components found but type is not tuple; report on GitHub');\n      }\n      let suffix = '';\n      const arrayBracket = param.type.indexOf('[');\n      if (arrayBracket >= 0) {\n        suffix = param.type.substring(arrayBracket);\n      }\n      const result = flattenTypes(includeTuple, param.components);\n      // console.log(\"result should have things: \" + result)\n      if (isArray(result) && includeTuple) {\n        // console.log(\"include tuple word, and its an array. joining...: \" + result.types)\n        types.push(`tuple(${result.join(',')})${suffix}`);\n      } else if (!includeTuple) {\n        // console.log(\"don't include tuple, but its an array. joining...: \" + result)\n        types.push(`(${result.join(',')})${suffix}`);\n      } else {\n        // console.log(\"its a single type within a tuple: \" + result.types)\n        types.push(`(${result})`);\n      }\n    } else {\n      // console.log(\"its a type and not directly in a tuple: \" + param.type)\n      types.push(param.type);\n    }\n  });\n\n  return types;\n};\n\nexport function bnToString(result: any): string | any {\n  if (BN.isBN(result)) {\n    return result.toString();\n  } else {\n    return result;\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-contract\n * @hidden\n */\n\nimport { AbiCoder as ABICoder, ParamType, toUtf8Bytes } from './abiCoder';\nimport { isObject, isArray } from 'avalanche-js-utils';\nimport { keccak256, Arrayish } from 'avalanche-js-crypto';\nimport { jsonInterfaceMethodToString, bnToString } from './utils';\n\nexport class AbiCoderClass {\n  coder: ABICoder;\n  constructor(coder: ABICoder) {\n    this.coder = coder;\n  }\n  encodeFunctionSignature(functionName: any) {\n    if (isObject(functionName)) {\n      functionName = jsonInterfaceMethodToString(functionName);\n    }\n    const result = keccak256(toUtf8Bytes(functionName));\n    return result.slice(0, 10);\n  }\n  encodeEventSignature(functionName: any) {\n    if (isObject(functionName)) {\n      functionName = jsonInterfaceMethodToString(functionName);\n    }\n    const result = keccak256(toUtf8Bytes(functionName));\n    return result;\n  }\n  encodeParameter(types: string | ParamType, param: any) {\n    return this.encodeParameters([types], [param]);\n  }\n  encodeParameters(types: Array<string | ParamType>, params: any[]) {\n    return this.coder.encode(types, params);\n  }\n  encodeFunctionCall(jsonInterface: any, params: any[]) {\n    return (\n      this.encodeFunctionSignature(jsonInterface) +\n      this.encodeParameters(jsonInterface.inputs, params).replace('0x', '')\n    );\n  }\n  decodeParameter(type: ParamType, bytes: Arrayish) {\n    return this.decodeParameters([type], bytes)[0];\n  }\n  decodeParameters(outputs: ParamType[], bytes: Arrayish) {\n    if (isArray(outputs) && outputs.length === 0) {\n      throw new Error('Empty outputs array given!');\n    }\n\n    if (!bytes || bytes === '0x' || bytes === '0X') {\n      throw new Error(`Invalid bytes string given: ${bytes}`);\n    }\n\n    const result = this.coder.decode(outputs, bytes);\n\n    const returnValues: any = {};\n    let decodedValue;\n\n    if (isArray(result)) {\n      if (outputs.length > 1) {\n        outputs.forEach((output: any, i) => {\n          decodedValue = result[i];\n\n          if (decodedValue === '0x') {\n            decodedValue = null;\n          }\n\n          returnValues[i] = bnToString(decodedValue);\n\n          if (isObject(output) && output.name) {\n            returnValues[output.name] = bnToString(decodedValue);\n          }\n        });\n\n        return returnValues;\n      }\n\n      return bnToString(result);\n    }\n\n    if (isObject(outputs[0]) && outputs[0].name) {\n      returnValues[outputs[0].name] = bnToString(result);\n    }\n\n    returnValues[0] = bnToString(result);\n\n    return returnValues;\n  }\n\n  decodeLog(inputs: any, data = '', topics: any) {\n    const returnValues: any = {};\n    let topicCount = 0;\n    let value;\n    const nonIndexedInputKeys: any[] = [];\n    const nonIndexedInputItems: any[] = [];\n\n    if (!isArray(topics)) {\n      topics = [topics];\n    }\n\n    inputs.forEach((input: any, i: number) => {\n      if (input.indexed) {\n        if (input.type === 'string') {\n          return;\n        }\n\n        value = topics[topicCount];\n\n        if (this.isStaticType(input.type)) {\n          value = this.decodeParameter(input.type, topics[topicCount]);\n        }\n\n        returnValues[i] = bnToString(value);\n        returnValues[input.name] = bnToString(value);\n        topicCount++;\n\n        return;\n      }\n\n      nonIndexedInputKeys.push(i);\n      nonIndexedInputItems.push(input);\n    });\n\n    if (data) {\n      const values = this.decodeParameters(nonIndexedInputItems, data);\n\n      let decodedValue;\n      nonIndexedInputKeys.forEach((itemKey, index) => {\n        decodedValue = values[index];\n\n        returnValues[itemKey] = bnToString(decodedValue);\n        returnValues[nonIndexedInputItems[index].name] = bnToString(decodedValue);\n      });\n    }\n\n    return returnValues;\n  }\n  isStaticType(type: any) {\n    if (type === 'bytes') {\n      return false;\n    }\n\n    if (type === 'string') {\n      return false;\n    }\n\n    if (type.indexOf('[') && type.slice(type.indexOf('[')).length === 2) {\n      return false;\n    }\n\n    return true;\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-contract\n * @hidden\n */\n\nimport { AbiCoderClass } from './api';\nimport { AbiCoder as EtherCoder } from './abiCoder';\n\nexport function AbiCoder() {\n  return new AbiCoderClass(new EtherCoder());\n}\n","/**\n * @packageDocumentation\n * @module avalanche-contract\n * @hidden\n */\n\nimport { isArray } from 'avalanche-js-utils';\nimport { AbiItemModel, AbiOutput, AbiInput } from './types';\n\nexport class AbiItem {\n  abiItem: AbiItemModel;\n  signature: string;\n  name: string;\n  payable: boolean;\n  anonymous: boolean;\n  type?: string;\n  inputs?: AbiInput[];\n  outputs?: AbiOutput[];\n  contractMethodParameters: any[];\n\n  // constructor\n  constructor(abiItem: AbiItemModel | any) {\n    this.abiItem = abiItem;\n    this.signature = this.abiItem.signature;\n    this.name = this.abiItem.name;\n    this.payable = this.abiItem.payable;\n    this.anonymous = this.abiItem.anonymous;\n    this.type = this.abiItem.type;\n    this.inputs = this.abiItem.inputs;\n    this.outputs = this.abiItem.outputs;\n    this.contractMethodParameters = [];\n  }\n\n  getInputLength() {\n    if (isArray(this.abiItem.inputs)) {\n      return this.abiItem.inputs.length;\n    }\n\n    return 0;\n  }\n\n  getInputs() {\n    if (isArray(this.abiItem.inputs)) {\n      return this.abiItem.inputs;\n    }\n\n    return [];\n  }\n\n  getOutputs() {\n    if (isArray(this.abiItem.outputs)) {\n      return this.abiItem.outputs;\n    }\n\n    return [];\n  }\n\n  getIndexedInputs() {\n    return this.getInputs().filter((input) => {\n      return input.indexed === true;\n    });\n  }\n\n  isOfType(type: string) {\n    return this.abiItem.type === type;\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-contract\n * @hidden\n */\n\nexport enum ContractStatus {\n  INITIALISED = 'initialised',\n  TESTED = 'tested',\n  ERROR = 'error',\n  SIGNED = 'signed',\n  SENT = 'sent',\n  REJECTED = 'rejected',\n  DEPLOYED = 'deployed',\n  CALLED = 'called',\n}\n","/**\n * @packageDocumentation\n * @module avalanche-contract\n * @hidden\n */\n\nimport { AbiItemModel } from './types';\n\nexport class AbiModel {\n  abi: any;\n\n  constructor(mappedAbi: any) {\n    this.abi = mappedAbi;\n  }\n\n  getMethod(name: string): AbiItemModel | false {\n    if (this.hasMethod(name)) {\n      return this.abi.methods[name];\n    }\n\n    return false;\n  }\n\n  getMethods(): AbiItemModel[] {\n    return this.abi.methods;\n  }\n\n  getEvent(name: string): AbiItemModel | false {\n    if (this.hasEvent(name)) {\n      return this.abi.events[name];\n    }\n\n    return false;\n  }\n\n  getFallback(): AbiItemModel | false {\n    if (this.hasFallback()) {\n      return this.abi.fallback;\n    }\n    return false;\n  }\n\n  getReceive(): AbiItemModel | false {\n    if (this.hasReceive()) {\n      return this.abi.receive;\n    }\n    return false;\n  }\n\n  getEvents(): AbiItemModel[] {\n    return this.abi.events;\n  }\n\n  getEventBySignature(signature: string): AbiItemModel | undefined {\n    let event;\n\n    Object.keys(this.abi.events).forEach((key) => {\n      if (this.abi.events[key].signature === signature) {\n        event = this.abi.events[key];\n      }\n    });\n\n    return event;\n  }\n\n  hasMethod(name: string): boolean {\n    return typeof this.abi.methods[name] !== 'undefined';\n  }\n\n  hasFallback(): boolean {\n    return typeof this.abi.fallback !== 'undefined';\n  }\n\n  hasReceive(): boolean {\n    return typeof this.abi.receive !== 'undefined';\n  }\n\n  hasEvent(name: string): boolean {\n    return typeof this.abi.events[name] !== 'undefined';\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-contract\n * @hidden\n */\n\nimport { isArray } from 'avalanche-js-utils';\nimport { AbiItem } from '../models/AbiItemModel';\nimport { AbiModel } from '../models/AbiModel';\nimport { AbiItemModel } from '../models/types';\nimport { jsonInterfaceMethodToString } from '../abi/utils';\nimport { AbiCoderClass } from '../abi/api';\n\nexport const abiMapper = (abi: any[], abiCoder: AbiCoderClass): AbiModel => {\n  const mappedAbiItems: any = {\n    methods: {},\n    events: {},\n    fallback: undefined,\n    receive: undefined,\n  };\n  let hasConstructor = false;\n\n  abi.forEach((abiItem: AbiItemModel) => {\n    abiItem.constant = isConstant(abiItem);\n    abiItem.payable = isPayable(abiItem);\n\n    if (abiItem.name) {\n      abiItem.funcName = jsonInterfaceMethodToString(abiItem);\n    }\n\n    let abiItemModel;\n\n    if (abiItem.type === 'function') {\n      abiItem.signature = abiCoder.encodeFunctionSignature(abiItem.funcName);\n\n      abiItemModel = new AbiItem(abiItem);\n\n      // Check if an method already exists with this name and if it exists than create an array and push this abiItem\n      // into it. This will be used if there are methods with the same name but with different arguments.\n      if (!mappedAbiItems.methods[abiItem.name]) {\n        mappedAbiItems.methods[abiItem.name] = abiItemModel;\n      } else {\n        if (isArray(mappedAbiItems.methods[abiItem.name])) {\n          mappedAbiItems.methods[abiItem.name].push(abiItemModel);\n        } else {\n          mappedAbiItems.methods[abiItem.name] = [\n            mappedAbiItems.methods[abiItem.name],\n            abiItemModel,\n          ];\n        }\n      }\n\n      mappedAbiItems.methods[abiItem.signature] = abiItemModel;\n      mappedAbiItems.methods[abiItem.funcName] = abiItemModel;\n\n      return;\n    }\n\n    if (abiItem.type === 'event') {\n      abiItem.signature = abiCoder.encodeEventSignature(abiItem.funcName);\n\n      abiItemModel = new AbiItem(abiItem);\n\n      if (\n        !mappedAbiItems.events[abiItem.name] ||\n        mappedAbiItems.events[abiItem.name].name === 'bound '\n      ) {\n        mappedAbiItems.events[abiItem.name] = abiItemModel;\n      }\n\n      mappedAbiItems.events[abiItem.signature] = abiItemModel;\n      mappedAbiItems.events[abiItem.funcName] = abiItemModel;\n    }\n\n    if (abiItem.type === 'fallback' || abiItem.type === 'receive') {\n      abiItem.signature = abiItem.type;\n      mappedAbiItems[abiItem.type] = new AbiItem(abiItem);\n    }\n\n    if (abiItem.type === 'constructor') {\n      abiItem.signature = abiItem.type;\n      // tslint:disable-next-line: no-string-literal\n      mappedAbiItems.methods['contractConstructor'] = new AbiItem(abiItem);\n\n      hasConstructor = true;\n    }\n  });\n  if (!hasConstructor) {\n    // tslint:disable-next-line: no-string-literal\n    mappedAbiItems.methods['contractConstructor'] = new AbiItem({\n      inputs: [],\n      payable: false,\n      constant: false,\n      type: 'constructor',\n    });\n  }\n  return new AbiModel(mappedAbiItems);\n};\n\nexport const isConstant = (abiItem: AbiItemModel) => {\n  return (\n    abiItem.stateMutability === 'view' || abiItem.stateMutability === 'pure' || abiItem.constant\n  );\n};\n\nexport const isPayable = (abiItem: AbiItemModel) => {\n  return abiItem.stateMutability === 'payable' || abiItem.payable;\n};\n","/**\n * @packageDocumentation\n * @module avalanche-contract\n */\n\nimport { Wallet } from 'avalanche-js-account';\nimport { TransactionFactory, Transaction, TxStatus } from 'avalanche-js-transaction';\nimport { RPCMethod, getResultForData, Emitter } from 'avalanche-js-network';\nimport { hexToBN, Unit } from 'avalanche-js-utils';\nimport { getAddress } from 'avalanche-js-crypto';\nimport { AbiItemModel } from '../models/types';\nimport { Contract } from '../contract';\nimport { methodEncoder } from '../utils/encoder';\nimport { ContractStatus } from '../utils/status';\n\nexport class ContractMethod {\n  contract: Contract;\n  params: any;\n  methodKey: string;\n  wallet: Wallet | any;\n  abiItem: AbiItemModel;\n  callResponse?: any;\n  callPayload?: any;\n\n  protected transaction: Transaction;\n  constructor(methodKey: string, params: any, abiItem: AbiItemModel, contract: Contract) {\n    this.methodKey = methodKey;\n    this.contract = contract;\n    this.wallet = contract.wallet;\n    this.params = params;\n    this.abiItem = abiItem;\n    this.transaction = this.createTransaction();\n    this.callPayload = undefined;\n    this.callResponse = undefined;\n  }\n  send(params: any): Emitter {\n    if (params && !params.gasLimit) {\n      params.gasLimit = params.gas;\n    }\n    try {\n      let gasLimit: any = params.gasLimit; // change by estimateGas\n      const signTxs = () => {\n        this.transaction = this.transaction.map((tx: any) => {\n          return { ...tx, ...params, gasLimit };\n        });\n\n        const waitConfirm: boolean = params && params.waitConfirm === false ? false : true;\n        const updateNonce: boolean = params && params.nonce !== undefined ? false : true;\n        this.signTransaction(updateNonce)\n          .then((signed) => {\n            this.sendTransaction(signed).then((sent) => {\n              const [txn, id] = sent;\n              this.transaction = txn;\n              this.contract.transaction = this.transaction;\n              if (this.transaction.isRejected()) {\n                this.transaction.emitter.reject(id); // in this case, id is error message\n              } else if (waitConfirm) {\n                this.confirm(id).then(() => {\n                  this.transaction.emitter.resolve(this.contract);\n                });\n              } else {\n                this.transaction.emitter.resolve(this.contract);\n              }\n            });\n          })\n          .catch((error) => {\n            this.transaction.emitter.reject(error);\n          });\n      };\n\n      if (gasLimit === undefined) {\n        this.estimateGas(params).then((gas) => {\n          gasLimit = hexToBN(gas);\n          signTxs();\n        });\n      } else {\n        signTxs();\n      }\n      return this.transaction.emitter;\n    } catch (error) {\n      throw error;\n    }\n  }\n  async call(options: any, blockNumber: any = 'latest') {\n    if (options && !options.gasLimit) {\n      options.gasLimit = options.gas;\n    }\n    try {\n      const shardID =\n        options !== undefined && options.shardID !== undefined\n          ? options.shardID\n          : this.contract.shardID;\n\n      this.transaction = this.transaction.map((tx: any) => {\n        return {\n          ...tx,\n          ...options,\n          nonce: 0,\n        };\n      });\n      const keys: string[] = Object.keys(this.transaction.txPayload);\n\n      interface TxPayload {\n        [key: string]: any;\n        from?: string;\n        to?: string;\n        shardID?: string;\n        gas?: string;\n        gasPrice?: string;\n        value?: string;\n        data?: string;\n        nonce?: string;\n      }\n      interface SendPayload {\n        [key: string]: any;\n        from?: string;\n        to?: string;\n        shardID?: string;\n        gas?: string;\n        gasPrice?: string;\n        value?: string;\n        data?: string;\n        nonce?: string;\n      }\n\n      const txPayload: TxPayload = this.transaction.txPayload;\n      const sendPayload: SendPayload = {};\n\n      for (const key of keys) {\n        // tslint:disable-next-line: no-unused-expression\n        if (txPayload[key] !== '0x') {\n          sendPayload[key] = txPayload[key];\n        }\n      }\n\n      const result =\n        // tslint:disable-line\n        await (<Wallet>this.wallet).messenger.send(\n          RPCMethod.Call,\n          [sendPayload, blockNumber],\n          // tslint:disable-line\n          (<Wallet>this.wallet).messenger.chainPrefix,\n          shardID,\n        );\n      this.callPayload = sendPayload;\n      this.callResponse = result;\n      if (result.isError()) {\n        throw result.message;\n      } else if (result.isResult()) {\n        if (result.result === null) {\n          return this.afterCall(undefined);\n        } else {\n          return this.afterCall(result.result);\n        }\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async estimateGas(options: any) {\n    try {\n      interface Payload {\n        [key: string]: any;\n      }\n\n      const estPayload: Payload = {};\n      const txPayload: Payload = this.transaction.txPayload;\n      const keys: string[] = ['from', 'to', 'gasPrice', 'value', 'data'];\n      for (const key of keys) {\n        if (options && options[key]) {\n          estPayload[key] = options[key];\n        } else if (txPayload[key] !== '0x') {\n          estPayload[key] = txPayload[key];\n        }\n      }\n\n      if (this.abiItem.isOfType('constructor')) {\n        delete estPayload.to;\n      }\n      const result = getResultForData(\n        // tslint:disable-line\n        await (<Wallet>this.wallet).messenger.send(RPCMethod.EstimateGas, [estPayload]),\n      );\n\n      if (result.responseType === 'error') {\n        throw result.message;\n      } else if (result.responseType === 'raw') {\n        throw new Error('Get estimateGas fail');\n      } else {\n        return result;\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  encodeABI() {\n    return methodEncoder(this.contract.abiCoder, this.abiItem, this.contract.data);\n  }\n\n  public debug() {\n    return {\n      callResponse: this.callResponse,\n      callPayload: this.callPayload,\n    };\n  }\n\n  protected async signTransaction(updateNonce: boolean) {\n    try {\n      let signed;\n      signed = this.wallet.signer\n        ? await this.wallet.signTransaction(\n            this.transaction,\n            this.wallet.signer,\n            undefined,\n            updateNonce,\n            'rlp',\n            'latest', // 'pending',\n          )\n        : await this.wallet.signTransaction(\n            this.transaction,\n            updateNonce,\n            'rlp',\n            'latest', // 'pending',\n          );\n      if (this.abiItem.isOfType('constructor')) {\n        this.contract.address = TransactionFactory.getContractAddress(signed);\n      }\n      this.contract.setStatus(ContractStatus.SIGNED);\n      return signed;\n    } catch (error) {\n      throw error;\n    }\n  }\n  protected async sendTransaction(signed: Transaction) {\n    try {\n      const result = await signed.sendTransaction();\n      this.contract.setStatus(ContractStatus.SENT);\n      return result;\n    } catch (error) {\n      throw error;\n    }\n  }\n  protected async confirm(id: string) {\n    try {\n      const result = await this.transaction.confirm(\n        id,\n        20,\n        1000,\n        this.transaction ? this.transaction.txParams.shardID : this.contract.shardID,\n      );\n\n      if (result.receipt && result.txStatus === TxStatus.CONFIRMED) {\n        if (this.abiItem.isOfType('constructor')) {\n          this.contract.setStatus(ContractStatus.DEPLOYED);\n        } else {\n          this.contract.setStatus(ContractStatus.CALLED);\n        }\n      } else {\n        this.contract.setStatus(ContractStatus.REJECTED);\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  protected createTransaction() {\n    if (this.wallet.messenger) {\n      if (this.abiItem.isOfType('constructor')) {\n        // tslint:disable-next-line: no-string-literal\n        this.contract.data = this.params[0]['data'] || '0x';\n\n        this.abiItem.contractMethodParameters =\n          // tslint:disable-next-line: no-string-literal\n          this.params[0]['arguments'] || [];\n      } else {\n        this.abiItem.contractMethodParameters = this.params || [];\n      }\n      const defaultOptions = {\n        gasLimit: new Unit(21000000).asWei().toWei(),\n        gasPrice: new Unit(1).asGwei().toWei(),\n      };\n      const txObject = {\n        ...defaultOptions,\n        ...this.contract.options,\n        ...this.params[0],\n        to: this.abiItem.isOfType('constructor')\n          ? '0x'\n          : getAddress(this.contract.address).checksum,\n        data: this.encodeABI(),\n      };\n      // tslint:disable-line\n      const result = new TransactionFactory((<Wallet>this.wallet).messenger).newTx(txObject);\n\n      return result;\n    } else {\n      throw new Error('Messenger is not found');\n    }\n  }\n\n  protected afterCall(response: any) {\n    // length of `0x${methodSig}` is 2+4*2=10\n    if (response.length % 32 === 10 && response.startsWith(this.contract.errorFuncSig)) {\n      const errmsg = this.contract.abiCoder.decodeParameters(\n        [{ type: 'string' }],\n        '0x' + response.slice(10),\n      );\n      throw { revert: errmsg[0] };\n    }\n\n    if (\n      this.abiItem.isOfType('constructor') ||\n      this.abiItem.isOfType('fallback') ||\n      this.abiItem.isOfType('receive')\n    ) {\n      return response;\n    }\n\n    const outputs = this.abiItem.getOutputs();\n    if (outputs.length === 0) {\n      // if outputs is empty, we can't know the call is revert or not\n      return response;\n    }\n    if (!response || response === '0x') {\n      // if outputs isn't empty, treat it as revert\n      throw { revert: response };\n    }\n    if (outputs.length > 1) {\n      return this.contract.abiCoder.decodeParameters(outputs, response);\n    }\n    return this.contract.abiCoder.decodeParameter(outputs[0], response);\n    // return outputs;\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-contract\n * @hidden\n */\n\nimport { isArray } from 'avalanche-js-utils';\nimport { AbiItemModel } from '../models/types';\nimport { AbiCoderClass } from '../abi/api';\n\nexport const methodEncoder = (\n  abiCoder: AbiCoderClass,\n  abiItemModel: AbiItemModel,\n  deployData: string,\n) => {\n  if (abiItemModel.isOfType('receive')) {\n    return undefined;\n  }\n  if (abiItemModel.isOfType('fallback')) {\n    return abiItemModel.contractMethodParameters.length\n      ? abiItemModel.contractMethodParameters[0]\n      : undefined;\n  }\n\n  let encodedParameters = abiCoder.encodeParameters(\n    abiItemModel.getInputs(),\n    abiItemModel.contractMethodParameters,\n  );\n\n  if (encodedParameters.startsWith('0x')) {\n    encodedParameters = encodedParameters.slice(2);\n  }\n\n  if (abiItemModel.isOfType('constructor')) {\n    if (!deployData) {\n      throw new Error(\n        'The contract has no contract data option set. This is necessary to append the constructor parameters.',\n      );\n    }\n\n    return deployData + encodedParameters;\n  }\n\n  if (abiItemModel.isOfType('function')) {\n    return abiItemModel.signature + encodedParameters;\n  }\n\n  return encodedParameters;\n};\n\nexport const eventFilterEncoder = (\n  abiCoder: AbiCoderClass,\n  abiItemModel: AbiItemModel,\n  filter: any,\n) => {\n  const topics: any[] = [];\n\n  abiItemModel.getIndexedInputs().forEach((input) => {\n    if (filter[input.name]) {\n      let filterItem = filter[input.name];\n\n      if (isArray(filterItem)) {\n        filterItem = filterItem.map((item: any) => {\n          return abiCoder.encodeParameter(input.type, item);\n        });\n\n        topics.push(filterItem);\n\n        return;\n      }\n\n      topics.push(abiCoder.encodeParameter(input.type, filterItem));\n\n      return;\n    }\n\n    topics.push(null);\n  });\n\n  return topics;\n};\n","/**\n * @packageDocumentation\n * @module avalanche-contract\n * @hidden\n */\n\nimport { AbiCoderClass } from '../abi/api';\nimport { AbiModel } from '../models/types';\nimport { Contract } from '../contract';\nimport { ContractMethod } from './method';\n\nexport class MethodFactory {\n  contract: Contract;\n  abiModel: any | AbiModel;\n  abiCoder: AbiCoderClass;\n  private methodKeys: string[];\n\n  // constructor\n  constructor(contract: Contract) {\n    this.contract = contract;\n    this.abiModel = this.contract.abiModel;\n    this.abiCoder = this.contract.abiCoder;\n    this.methodKeys = this.mapMethodKeys();\n  }\n\n  addMethodsToContract() {\n    this.methodKeys.forEach((key: string) => {\n      const newObject: any = {};\n      newObject[key] = (...params: any[]) =>\n        new ContractMethod(key, params, this.abiModel.getMethod(key), this.contract);\n\n      Object.assign(this.contract.methods, newObject);\n    });\n    if (this.abiModel.hasFallback()) {\n      this.contract.fallback = (calldata: string) =>\n        new ContractMethod('fallback', [calldata], this.abiModel.getFallback(), this.contract);\n    }\n    if (this.abiModel.hasReceive()) {\n      this.contract.receive = () =>\n        new ContractMethod('receive', [], this.abiModel.getReceive(), this.contract);\n    }\n    return this.contract;\n  }\n  /**\n   * @function mapMethodKeys\n   * @return {string[]} {description}\n   */\n  private mapMethodKeys(): string[] {\n    return Object.keys(this.abiModel.abi.methods);\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-contract\n * @hidden\n */\n\nimport { hexlify, isHexString, keccak256, toChecksumAddress } from 'avalanche-js-crypto';\nimport {\n  numberToHex,\n  isArray,\n  // hexToNumber,\n  isString,\n  isAddress,\n  hexToBN,\n} from 'avalanche-js-utils';\nimport { toUtf8Bytes } from '../abi/abiCoder';\n\nexport const inputLogFormatter = (options: any) => {\n  if (options.fromBlock) {\n    options.fromBlock = inputBlockNumberFormatter(options.fromBlock);\n  }\n\n  if (options.toBlock) {\n    options.toBlock = inputBlockNumberFormatter(options.toBlock);\n  }\n\n  // make sure topics, get converted to hex\n  options.topics = options.topics || [];\n  options.topics = options.topics.map((topic: any) => {\n    return isArray(topic) ? topic.map(toTopic) : toTopic(topic);\n  });\n\n  if (options.address) {\n    if (isArray(options.address)) {\n      options.address = options.address.map((addr: string) => {\n        return inputAddressFormatter(addr);\n      });\n    } else {\n      options.address = inputAddressFormatter(options.address);\n    }\n  }\n\n  return options;\n};\n\n/**\n * Formats the output of a log\n *\n * @method outputLogFormatter\n *\n * @param {Object} log object\n *\n * @returns {Object} log\n */\nexport const outputLogFormatter = (log: any) => {\n  // generate a custom log id\n  if (\n    typeof log.blockHash === 'string' &&\n    typeof log.transactionHash === 'string' &&\n    typeof log.logIndex === 'string'\n  ) {\n    const shaId = keccak256(\n      '0x' +\n        log.blockHash.replace('0x', '') +\n        log.transactionHash.replace('0x', '') +\n        log.logIndex.replace('0x', ''),\n    );\n\n    shaId.replace('0x', '').substr(0, 8);\n\n    log.id = `log_${shaId}`;\n  } else if (!log.id) {\n    log.id = null;\n  }\n\n  if (log.blockNumber !== null) {\n    log.blockNumber = hexToBN(log.blockNumber).toNumber();\n  }\n\n  if (log.transactionIndex !== null) {\n    log.transactionIndex = hexToBN(log.transactionIndex).toNumber();\n  }\n\n  if (log.logIndex !== null) {\n    log.logIndex = hexToBN(log.logIndex).toNumber();\n  }\n\n  if (log.address) {\n    log.address = toChecksumAddress(log.address);\n  }\n\n  return log;\n};\n\nexport const inputBlockNumberFormatter = (blockNumber: any) => {\n  if (blockNumber === undefined || blockNumber === null || isPredefinedBlockNumber(blockNumber)) {\n    return blockNumber;\n  }\n\n  if (isHexString(blockNumber)) {\n    if (isString(blockNumber)) {\n      return blockNumber.toLowerCase();\n    }\n\n    return blockNumber;\n  }\n\n  return numberToHex(blockNumber);\n};\n\nexport const isPredefinedBlockNumber = (blockNumber: string) => {\n  return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest';\n};\n\nexport const inputAddressFormatter = (address: string) => {\n  if (isAddress(address)) {\n    return `0x${address.toLowerCase().replace('0x', '')}`;\n  }\n\n  throw new Error(\n    `Provided address \"${address}\" is invalid, the capitalization checksum test failed, or its an indrect IBAN address which can't be converted.`,\n  );\n};\n\nexport const toTopic = (value: any) => {\n  if (value === null || typeof value === 'undefined') {\n    return null;\n  }\n\n  value = String(value);\n\n  if (value.indexOf('0x') === 0) {\n    return value;\n  }\n\n  return hexlify(toUtf8Bytes(value));\n};\n","/**\n * @packageDocumentation\n * @module avalanche-contract\n */\n\nimport { LogSub } from 'avalanche-js-network';\nimport { AbiItemModel } from '../models/types';\nimport { Contract } from '../contract';\nimport { decode as eventLogDecoder } from '../utils/decoder';\nimport { inputLogFormatter, outputLogFormatter } from '../utils/formatter';\nexport class EventMethod extends LogSub {\n  params: any;\n  methodKey: string;\n  contract: Contract;\n  abiItem: AbiItemModel;\n  constructor(methodKey: string, params: any, abiItem: AbiItemModel, contract: Contract) {\n    super(inputLogFormatter(params), contract.wallet.messenger, contract.shardID);\n    this.methodKey = methodKey;\n    this.contract = contract;\n    this.params = params;\n    this.abiItem = abiItem;\n    // this.subscribe();\n  }\n\n  // call() {}\n  // estimateGas() {}\n  // encodeABI() {}\n\n  onNewSubscriptionItem(subscriptionItem: any) {\n    const formatted = outputLogFormatter(\n      subscriptionItem.method !== undefined ? subscriptionItem.params.result : subscriptionItem,\n    );\n    const log = eventLogDecoder(this.contract.abiCoder, this.abiItem, formatted);\n\n    if (log.removed && this.emitter) {\n      this.emitter.emit('changed', log);\n    }\n\n    return log;\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-contract\n * @hidden\n */\n\nimport { AbiItemModel } from '../models/types';\nimport { AbiCoderClass } from '../abi/api';\n\nexport const decode = (abiCoder: AbiCoderClass, abiItemModel: AbiItemModel, response: any) => {\n  let argumentTopics = response.topics;\n\n  if (!abiItemModel.anonymous) {\n    argumentTopics = response.topics.slice(1);\n  }\n\n  if (response.data === '0x') {\n    response.data = null;\n  }\n\n  response.returnValues = abiCoder.decodeLog(\n    abiItemModel.getInputs(),\n    response.data,\n    argumentTopics,\n  );\n  response.event = abiItemModel.name;\n  response.signature = abiItemModel.signature;\n  response.raw = {\n    data: response.data,\n    topics: response.topics,\n  };\n\n  if (abiItemModel.anonymous || !response.topics[0]) {\n    response.signature = null;\n  }\n\n  delete response.data;\n  delete response.topics;\n\n  return response;\n};\n","/**\n * @packageDocumentation\n * @module avalanche-contract\n * @hidden\n */\n\nimport { isArray } from 'avalanche-js-utils';\nimport { AbiCoderClass } from '../abi/api';\nimport { AbiModel, AbiItemModel } from '../models/types';\nimport { Contract } from '../contract';\nimport { EventMethod } from './event';\nimport { inputBlockNumberFormatter } from '../utils/formatter';\nimport { eventFilterEncoder } from '../utils/encoder';\n\nexport class EventFactory {\n  contract: Contract;\n  abiModel: any | AbiModel;\n  abiCoder: AbiCoderClass;\n  private eventKeys: string[];\n\n  // constructor\n  constructor(contract: Contract) {\n    this.contract = contract;\n    this.abiModel = this.contract.abiModel;\n    this.abiCoder = this.contract.abiCoder;\n    this.eventKeys = this.mapEventKeys();\n  }\n\n  addEventsToContract() {\n    this.eventKeys.forEach((key: string) => {\n      const newObject: any = {};\n      newObject[key] = (params: any) =>\n        new EventMethod(\n          key,\n          // params,\n          this.map(this.abiModel.getEvent(key), this.contract, params),\n          this.abiModel.getEvent(key),\n          this.contract,\n        );\n      Object.assign(this.contract.events, newObject);\n    });\n    return this.contract;\n  }\n  /**\n   * @function mapMethodKeys\n   * @return {string[]} {description}\n   */\n  private mapEventKeys(): string[] {\n    return Object.keys(this.abiModel.abi.events);\n  }\n\n  private map(abiItemModel: AbiItemModel, contract: Contract, options: any) {\n    if (!options) {\n      options = {};\n    }\n\n    if (!isArray(options.topics)) {\n      options.topics = [];\n    }\n\n    if (typeof options.fromBlock !== 'undefined') {\n      options.fromBlock = inputBlockNumberFormatter(options.fromBlock);\n    }\n    // else if (contract.defaultBlock !== null) {\n    //   options.fromBlock = contract.defaultBlock;\n    // }\n\n    if (typeof options.toBlock !== 'undefined') {\n      options.toBlock = inputBlockNumberFormatter(options.toBlock);\n    }\n\n    if (typeof options.filter !== 'undefined') {\n      options.topics = options.topics.concat(\n        eventFilterEncoder(this.abiCoder, abiItemModel, options.filter),\n      );\n      delete options.filter;\n    }\n\n    if (!abiItemModel.anonymous) {\n      options.topics.unshift(abiItemModel.signature);\n    }\n\n    if (!options.address) {\n      options.address = contract.address;\n    }\n\n    return options;\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-contract\n *\n */\n\nimport { Wallet } from 'avalanche-js-account';\nimport { Messenger } from 'avalanche-js-network';\nimport { Transaction } from 'avalanche-js-transaction';\nimport { AbiCoder } from './abi/index';\nimport { abiMapper } from './utils/mapper';\nimport { ContractOptions } from './utils/options';\nimport { AbiModel } from './models/types';\nimport { AbiCoderClass } from './abi/api';\nimport { MethodFactory } from './methods/methodFactory';\nimport { EventFactory } from './events/eventFactory';\nimport { ContractStatus } from './utils/status';\n\n// class Contract\nexport class Contract {\n  methods: any;\n  events: any;\n  fallback: any = undefined;\n  receive: any = undefined;\n  abi: any = [];\n  abiModel: any | AbiModel;\n  abiCoder: AbiCoderClass;\n  options: ContractOptions | any;\n  wallet: Wallet | any;\n  transaction?: Transaction;\n  status: ContractStatus;\n  shardID: number;\n  errorFunc: string = 'Error(string)';\n  errorFuncSig: string;\n\n  constructor(\n    abi: any = [],\n    address: string = '0x',\n    options: ContractOptions = {},\n    wallet: Wallet,\n    status: ContractStatus = ContractStatus.INITIALISED,\n  ) {\n    // super();\n    this.abi = abi;\n    this.abiCoder = AbiCoder();\n    this.abiModel = abiMapper(abi, this.abiCoder);\n    this.options = options;\n    this.address = this.options.address || address;\n    this.shardID = this.options.shardID || wallet.messenger.currentShard;\n    this.wallet = wallet;\n    this.methods = {};\n    this.events = {};\n    this.runMethodFactory();\n    this.runEventFactory();\n    this.status = status;\n    this.errorFuncSig = this.abiCoder.encodeFunctionSignature(this.errorFunc);\n    // tslint:disable-next-line: no-unused-expression\n  }\n  isInitialised() {\n    return this.status === ContractStatus.INITIALISED;\n  }\n  isSigned() {\n    return this.status === ContractStatus.SIGNED;\n  }\n  isSent() {\n    return this.status === ContractStatus.SENT;\n  }\n  isDeployed() {\n    return this.status === ContractStatus.DEPLOYED;\n  }\n  isRejected() {\n    return this.status === ContractStatus.REJECTED;\n  }\n  isCalled() {\n    return this.status === ContractStatus.CALLED;\n  }\n  setStatus(status: ContractStatus) {\n    this.status = status;\n  }\n\n  get jsonInterface(): any[] {\n    return this.abiModel;\n  }\n\n  set jsonInterface(value: any[]) {\n    this.abiModel = abiMapper(value, this.abiCoder);\n    this.runMethodFactory();\n    this.runEventFactory();\n  }\n\n  get address() {\n    return this.options.address || this.address;\n  }\n\n  set address(value: string) {\n    this.options.address = value;\n  }\n\n  get data() {\n    return this.options.data;\n  }\n\n  set data(value) {\n    this.options.data = value;\n  }\n\n  // deploy\n  deploy(options: any) {\n    return this.methods.contractConstructor(options);\n  }\n\n  runMethodFactory(): Contract {\n    return new MethodFactory(this).addMethodsToContract();\n  }\n  runEventFactory(): Contract {\n    return new EventFactory(this).addEventsToContract();\n  }\n  connect(wallet: Wallet): void {\n    this.wallet = wallet;\n  }\n  setMessegner(messenger: Messenger) {\n    if (this.wallet instanceof Wallet) {\n      this.wallet.setMessenger(messenger);\n    } else {\n      this.wallet.messenger = messenger;\n    }\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-contract\n */\n\nimport { Wallet } from 'avalanche-js-account';\nimport { Contract } from './contract';\nimport { ContractOptions } from './utils/options';\n\nexport class ContractFactory {\n  wallet: Wallet | any;\n\n  constructor(wallet: Wallet | any) {\n    this.wallet = wallet;\n  }\n  createContract(abi: any[], address?: string, options?: ContractOptions) {\n    return new Contract(abi, address, options, this.wallet);\n  }\n}\n"],"names":["NegativeAVAX","BN","AVAX","Zero","MaxUint256","hexToBN","paramTypeBytes","RegExp","paramTypeNumber","paramTypeArray","defaultCoerceFunc","type","value","match","parseInt","toString","verifyType","substring","parseParam","param","allowIndexed","originalParam","throwError","i","Error","replace","parent","name","state","allowType","node","length","c","allowParams","components","indexed","child","allowName","allowArray","sibling","push","readArray","Coder","coerceFunc","localName","dynamic","CoderAnonymous","coder","undefined","encode","this","decode","data","offset","CoderNull","_Coder2","arrayify","Uint8Array","consumed","CoderNumber","size","signed","result","v","startsWith","slice","bounds","maskn","gt","add","mul","lt","toTwos","fromTwos","vString","padZeros","error","INVALID_ARGUMENT","arg","coderType","hexlify","dataValue","uint256Coder","CoderBoolean","_Coder4","reason","isZero","CoderFixedBytes","arrayied","valueToByte","bytesPadRight","set","CoderAddress","_Coder6","addr","toChecksumAddress","_encodeDynamicBytes","dataLength","Math","ceil","padding","concat","_decodeDynamicBytes","toNumber","CoderDynamicBytes","_Coder7","CoderString","_Coder8","toUtf8Bytes","toUtf8String","alignSize","pack","coders","values","Array","isArray","arrayValues","forEach","parts","index","staticSize","dynamicSize","part","dynamicOffset","unpack","baseOffset","UnicodeNormalizationForm","CoderArray","count","checkArgumentCount","decodedLength","CoderTuple","types","join","paramTypeSimple","address","bool","string","bytes","getParamCoder","matcher","matcher2","matcher3","object","key","shallowCopy","deepCopy","component","getTupleParamCoder","str","form","current","checkNormalize","normalize","charCodeAt","c2","ignoreErrors","extraLength","overlongMask","res","j","nextChar","String","fromCharCode","isType","_ethersType","opaque","number","frozen","map","item","Object","freeze","defineReadOnly","AbiCoder","checkNew","typeObject","_this6","encodedArray","_this7","jsonInterfaceMethodToString","json","isObject","includes","flattenTypes","inputs","includeTuple","puts","suffix","arrayBracket","indexOf","bnToString","isBN","AbiCoderClass","encodeFunctionSignature","functionName","keccak256","encodeEventSignature","encodeParameter","encodeParameters","params","encodeFunctionCall","jsonInterface","decodeParameter","decodeParameters","outputs","decodedValue","returnValues","output","decodeLog","topics","topicCount","nonIndexedInputKeys","nonIndexedInputItems","input","_this","isStaticType","itemKey","EtherCoder","ContractStatus","AbiItem","abiItem","signature","payable","anonymous","contractMethodParameters","getInputLength","getInputs","getOutputs","getIndexedInputs","filter","isOfType","AbiModel","mappedAbi","abi","getMethod","hasMethod","methods","getMethods","getEvent","hasEvent","events","getFallback","hasFallback","fallback","getReceive","hasReceive","receive","getEvents","getEventBySignature","event","keys","abiMapper","abiCoder","mappedAbiItems","hasConstructor","abiItemModel","constant","isConstant","isPayable","funcName","stateMutability","ContractMethod","methodKey","contract","wallet","transaction","createTransaction","callPayload","callResponse","send","gasLimit","gas","signTxs","tx","waitConfirm","signTransaction","nonce","then","sendTransaction","sent","id","isRejected","emitter","reject","confirm","resolve","estimateGas","call","options","blockNumber","shardID","txPayload","sendPayload","messenger","RPCMethod","Call","chainPrefix","isError","message","isResult","afterCall","estPayload","to","getResultForData","EstimateGas","responseType","encodeABI","deployData","encodedParameters","methodEncoder","debug","updateNonce","signer","TransactionFactory","getContractAddress","setStatus","SIGNED","SENT","txParams","receipt","txStatus","TxStatus","CONFIRMED","DEPLOYED","CALLED","REJECTED","txObject","Unit","asWei","toWei","gasPrice","asGwei","getAddress","checksum","newTx","response","errorFuncSig","revert","MethodFactory","abiModel","methodKeys","mapMethodKeys","addMethodsToContract","newObject","assign","calldata","inputBlockNumberFormatter","isPredefinedBlockNumber","isHexString","isString","toLowerCase","numberToHex","inputAddressFormatter","isAddress","toTopic","EventMethod","fromBlock","toBlock","topic","onNewSubscriptionItem","subscriptionItem","argumentTopics","formatted","log","blockHash","transactionHash","logIndex","shaId","substr","transactionIndex","outputLogFormatter","method","raw","removed","emit","LogSub","EventFactory","eventKeys","mapEventKeys","addEventsToContract","filterItem","eventFilterEncoder","unshift","Contract","status","INITIALISED","currentShard","runMethodFactory","runEventFactory","errorFunc","isInitialised","isSigned","isSent","isDeployed","isCalled","deploy","contractConstructor","connect","setMessegner","Wallet","setMessenger","ContractFactory","createContract","text"],"mappings":"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"}